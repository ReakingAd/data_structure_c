## 总结
1. 关于链表的定义。
	
        typedef struct LNode * LinkList;

    链表被定义为指向结点的指针。因为链表可以由头指针唯一确定，例如：`LinkedList L;` 则`LinkedList`类型的变量`L`就是一个指向头结点的指针。
2.  头指针、头结点、第一个结点
    - **头指针**：链表必须有一个头指针。并定义为链表类型的变量就是这个头指针。例如:`LinkedList L` 中`L`就是头指针。当链表有头结点时，头指针指向头结点；当链表没有头结点时，头指针指向第一个结点。
    - **头结点**：头结点可有可无，可由程序员在实现链表时自由决定。头结点不同于链表的“第一个结点”。头结点数据域不存数据，或者存储链表的长度信息。头结点的指针域指向第一个结点。
    - **第一个结点**：链表中存储有数据的第一个实实在在的结点。

    链表带有头结点的好处：教科书中的链表实现选择带有头结点。在移动指针遍历链表时，可以从第一个结点开始，统一使用`p->next`表达式访问每一个结点。相反，如果不定义头结点，则只能通过`p`来访问第一个结点时，从第二个结点开始，使用`p->next`表达式访问结点。

3. 关于链表增删操作的指针参数。
    教科书中的链表插入实现函数原型为`Status ListInsert(LinkedList *,int,ElemType);`。第一个参数使用的是指向链表的指针。而网上看到有的实现中，第一个参数使用的是链表类型`LinkedList`，并做了注释说不改变原链表所以不用指针。因为`LinkedList`类型的变量本身就是一个指针，指向的是结点。所以这样做也能实现插入操作。
    但是为了让函数原型的功能看起来一目了然，还是将`LinkedList *`作为参数比较好，这样在使用该函数时可以在不追究结构`LinkedList`的定义的情况下，直接知道这个函数改变了指针参数所指向的数据。
4. 算法2.12 合并两个有序链表
   - 总体上说，合并两个有序链表的精髓就是，将新链表的指针按照数值非递减的顺序，在La、Lb的各个结点之间跳跃。La、Lb每个结点都路过一次后，新链表Lc就算是完成了。整个过程中，没有生成新的结点，只是改变了La、Lb两个链表的结点的链接顺序。也就是说，各个结点的内存地址没有动，只是指针域在改变，最终两个链表的结点共同串成了一个新链表。
   - 遍历指针pa,pb分别用来记录La、Lb中哪个结点是准备就绪，等待被比较的结点。pc是新链表的最后一个结点的指针。pc的运动轨迹就是最终合并完的链表。
   - `*Lc = pc = *La` 这一行，讲La的头结点作为Lc的头结点。 这一样也可以这样写`*Lc = pc = (LinkedList)malloc( sizeof(struct LNode) );`。意思就是新生成一个结点作为Lc的头结点。两种写法是有差别的。首先后者的空间负责度略高一些。从二者最终生成的Lc来看，两种方式生成Lc，只有头结点的内存地址（也就是头指针）不同，从第一个结点开始，后续所有结点都完全一致。
   - `pc -> next = pa;pc = pa;pa = pa -> next;`这三句，就是在移动`La`的'遍历指针'`pa`和`Lc`的'跳跃指针'`pc`。中间一句`pc=pa`相对难理解一些，其实就是`pc`跳跃到了`pa`所在的位置。这一句的等价写法`pc = pc -> next`会好理解一些，二者达到的效果是一样的。

## 问题

1. 算法2.12

   最后，`free(*Lb);Lb = NULL;`到底释放的是谁？是测试函数里面的Lb还是，MergeList()内部的Lb？（因为按值传递，传进来的Lb就是一个内存地址）。目前的代码，执行后，打印的Lb不对。即不是初始的246810,也不是空链表。
2. 定义指针变量时，说是最好将变量赋初值NULL。free()释放内存后，最好讲指针设置为NULL。
   定义一个链表LinkedList L; 将L的地址作为参数传给函数，不报警告。定义LinkedList * L;将L传给函数，就会报为初始化警告。是不是前者会自动寻找一个合法的地址，预备着以存放将来对L的赋值。后者没明确给出地址，L就会乱指？？