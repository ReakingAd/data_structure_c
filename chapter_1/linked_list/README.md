## 总结
1. 关于链表的定义。
	
        typedef struct LNode * LinkList;

    链表被定义为指向结点的指针。因为链表可以由头指针唯一确定，例如：`LinkedList L;` 则`LinkedList`类型的变量`L`就是一个指向头结点的指针。
2.  头指针、头结点、第一个结点
    - **头指针**：链表必须有一个头指针。并定义为链表类型的变量就是这个头指针。例如:`LinkedList L` 中`L`就是头指针。当链表有头结点时，头指针指向头结点；当链表没有头结点时，头指针指向第一个结点。
    - **头结点**：头结点可有可无，可由程序员在实现链表时自由决定。头结点不同于链表的“第一个结点”。头结点数据域不存数据，或者存储链表的长度信息。头结点的指针域指向第一个结点。
    - **第一个结点**：链表中存储有数据的第一个实实在在的结点。

    链表带有头结点的好处：教科书中的链表实现选择带有头结点。在移动指针遍历链表时，可以从第一个结点开始，统一使用`p->next`表达式访问每一个结点。相反，如果不定义头结点，则只能通过`p`来访问第一个结点时，从第二个结点开始，使用`p->next`表达式访问结点。

3. 关于链表增删操作的指针参数。
    教科书中的链表插入实现函数原型为`Status ListInsert(LinkedList *,int,ElemType);`。第一个参数使用的是指向链表的指针。而网上看到有的实现中，第一个参数使用的是链表类型`LinkedList`，并做了注释说不改变原链表所以不用指针。因为`LinkedList`类型的变量本身就是一个指针，指向的是结点。所以这样做也能实现插入操作。
    但是为了让函数原型的功能看起来一目了然，还是将`LinkedList *`作为参数比较好，这样在使用该函数时可以在不追究结构`LinkedList`的定义的情况下，直接知道这个函数改变了指针参数所指向的数据。
