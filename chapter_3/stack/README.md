### 总结

1. 在一个空的栈中，栈顶指针top=栈底指针base。栈顶指针***top始终指向栈顶元素的下一个位置***，也就是说top指向的位置，并没有元素存储。
   这容易被top和base的单词意义所误导，误认为top指向栈顶元素，base指向栈底元素。
2. 有关运算符优先级

    - `Push()`函数中`*(*S).top++ = e;`。`()`优先级最高，所以`(*S)`。`.`是父子继承关系，优先级高于`*`的自身运算。所以`(*S).top`。`++`会改变自身，优先级大于单纯的取值`*`,所以`(*S).top++`。注意，由于是后置自增，所以要等到将`e`的值赋值给`=`左侧的表达式之后，`(*S).top`才会进行自增操作。（***这样看来，在计算一个表达式时，后置自增/自减可以暂时忽略掉***）最后`*(*S).top++`
    - `Pop()`函数中`*e = *--(*S).top;`。运算符运算过程和上例相似，不同点在于自减运算符在前，所以自减要参与到整个表达式的计算并不可暂时忽略。
### 问题

2. 栈的top指针，可以补一个图
3. 打印一个销毁了的