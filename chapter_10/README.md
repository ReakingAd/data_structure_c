1. ***学习时间复杂度的计算*** 

### 总结
1. 在 `algo10.1` 线性表的实现中，直接在结构定义时定义了数组大小。所以就不需要`InitList()`函数了。
2. 算法10.1
    对于循环`for(i=0;i<3;i++){}`如果中间的判断条件不成立，则直接跳出循环，不但不执行循环体内的语句，`i++`也不会执行。例如：
    
        int i;
        for(i=0;i<3;i++){}
        printf("i=%d\n",i); // 打印3。如果最后依次i++也执行的话，会打印4
### 排序算法之间的关系

***插入排序***    
1.直接插入排序    O(n*n)    
2.折半插入排序    O(n*n)     
3.二路插入排序    
4.表插入排序      O(n*n)    
5.希尔排序        介于O(n*n)与O(n)之间。原小于O(n*n),去决定增量序列的选择。    

- 2与1相比，减少关键字比较次数。移动次数不变。
- 3与2相比，减少移动次数
- 4与2相比，移动次数变为0。但是必须改变数据结构---采用静态链表。因为这种算法使用修改指针来代替移动元素，所以为了使静态链表能够进行随机存取，还得重排数组。
- 正序的序列时间复杂度为O(n)。因此先找一个增量，得到一个子序列，对子序列进行`直接插入排序`。在对一系列增量做完这些后，原序列就变成“基本有序”。然后再进行`直接插入排序`

***快速排序***    


1.冒泡排序       O(n*n)    
2.快速排序       O(nlog(n))    

- 2是对1的改进，二者都是基于“交换”实现的排序。    

JavaScript中介绍的快速排序是：选取中间位置的元素作为支点(pivot),再建立两个空数组left,right。遍历数组，将所有小于pivot的放入left，所有大于pivot的放入right。
然后递归这个函数。    
数据结构中介绍的快速排序是：选取一个支点(pivot)，但是不使用空数组来分割原序列，而是通过指针的移动来做到分割序列。选择low，high两个指针（第一次为0和length-1）,
high向低位移动直到遇到第一个小于pivot的元素,将pivot和high两元素交换.再low向高位移动直到遇到第一个大于pivot的元素,交换low和pivot量元素.反复执行这一过程直到low=high非.此时变完成了依次分割,即pivot左侧的元素都小于pivot,pivot右侧元素都大于pivot.递归这个函数,对pivot左侧、右侧的子序列进行分割排列（注意选对low和high指针），直到传进来的low>=high跳出递归。

***选择排序***
1.简单选择排序               O(n*n)
2.树型选择排序(锦标赛排序)     O(n*logn)
3.堆排序                    O(n*logn)

- 2相比1，减少了比较次数，但是需要更多辅助存储空间。
- 3相比2，仅需要一个用于交换的辅助存储空间。
### 问题

1. 排序是稳定的。是什么意思看不懂。
2. 给整型赋值一个浮点型，会自动截取？？
3. 折半插入排序相比直接插入排序，仅减少了关键字的比较次数，而记录的移动次数不变，于是时间复杂度依然时O(n平方)
   为什么啊？减少了比较次数为什么时间复杂度不变呢？
4. 缺少2-路插入排序的算法实现！！！！！
5. 树型选择排序未实现！！！！！。堆排序写的不对！！！！！


