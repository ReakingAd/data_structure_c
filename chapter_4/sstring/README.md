### 总结

1. 使用定长数组实现的串中，`ClearString()`只需要将数组的长度置为0即可。也就是`S[0]=0;`。因为本实现中，其他串操作都是基于`S[0]`这个值的`for`循环。
   而串是定长数组实现的，所以串被初始化后，内存就已经被定量分配好，不存在内存回收的需求。

   ***顺序结构由于是使用数组来实现，那么当清空顺序结构的数据结构时，都只需要将长度的标志位置为0即可。而不需要担心内存回收的问题。链式存储结构实现的数据结构就需要手动回收内存，否则那些内存就不能被系统用作他用了，浪费。***

2. KMP算法的推导

   书中公式：    
   > p(1) ... p(k-1) = s(i-k+1) ... s(i-1)               ***（4-2）***    
   > p(j-k+1) ... p(j-1) = s(i-k+1) ... s(i-1)            ***(4-3)***    
   
   推出：    

   > p(1) ... p(k-1) = p(j-k+1) ... p(j-1)         ***(4-4)***        

   推导过程的解释：    

   当出现失配,即s(i)不等于p(j)时，将模式串向右滑动若干距离，使s(i),p(k)对齐，以便进行下一步的匹配判断。在此刻的状态下，观察主串和模式串，可以得到公式(4-2)
   
   ***公式（4-2）的含义是：模式串的前k-1个元素组成的子串，与主串s(i)前的k-1个元素组成的子串相等。***

   由已经得到的部分匹配可知，p(j)的前j-1个元素组成的淄川与s(i)的前j-1个元素组成的子串相等。0<k<j。显然p(j)的前j-k+1个元素组成的淄川与s(i)的前j-k+1个元素组成的子串相等。也就是公式(4-3)

   公式(4-2)(4-3)推出公式(4-4)。公式(4-4)的含义是：

   ***部分匹配的子串中，串首的k-1个元素组成的新子串，与串尾k-1个元素组成的新子串相等。***

   也即是说，当遇到失配时，只需要在部分匹配的1 ～ j之间，找到一个k，使得部分匹配的子串满足公式(4-4)。然后让模式的指针指向k，主串的指针不动仍然指向i，继续判断匹配就行了。而这个k值，就需要通过函数`next[j]`来获取。

3. 模式串next[j]函数的推导

### 问题

1. 缺4.1
2. 缺少使用堆空间实现的串，`HString`。4.4 之后没实现。
3. 缺少串的块链存储 
4. 缺少next[j]函数的推导过程理解
5. 串的应用：建立词索引表

